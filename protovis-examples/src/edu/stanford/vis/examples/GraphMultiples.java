package edu.stanford.vis.examples;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.swing.JFrame;

import pv.mark.Mark;
import pv.mark.Scene;
import pv.mark.constants.MarkType;
import pv.render.awt.CameraControl;
import pv.render.awt.gl.GLDisplay;
import pv.style.Stroke;

/**
 * Example demonstrating how to overlay multiple edge sets. Highlights some of
 * the possibilities supported by Protovis Link mark types.
 */
public class GraphMultiples {

	public static void main(String[] args) {
		System.out.println("Click and drag to pan the view.");
		System.out.println("Hold the Shift key and click and drag vertically to zoom.");
		
		// -- data ---
		
		// first create a set of 10 nodes
		// we will reuse this node set for each graph instance
		int N = 10;
		List<Integer> nodes = new ArrayList<Integer>();
		for (int i=0; i<N; ++i) {
			nodes.add(i);
		}
		
		// now create two sets of edges
		// set 1 connects nodes in sequence - we will use it for each node set
		// set 2 connects two node sets together
		List<int[]> edges1 = new ArrayList<int[]>();
		List<int[]> edges2 = new ArrayList<int[]>();
		for (int i=1; i<N; ++i) {
			edges1.add(new int[] {i-1, i});
			for (int j=i; j<i+3 && j<N; ++j) {
				edges2.add(new int[] {i-1, j});
			}
		}
		
		// -- vis ---
		
		// default property definitions for visualized edges 
		Mark e = Mark.create()
			.data(edges1) // use edge set 1 as the data
			.datatype(int[].class)
			.sourceKey("{{data[0]}}") // foreign key to source node
			.targetKey("{{data[1]}}") // foreign key to target node
			.stroke(Stroke.solid(1, 0xdedede));
		
		// default property definitions for visualized nodes
		Mark n = Mark.create()
			.data(nodes) // use node set as the data
			.datatype(Integer.class)
			.left("{{25*(index+1)}}") // place nodes in horizontal sequence
			.size(100).stroke(Stroke.solid(1, 0x3333aa));
		
		// define the root of the visual scene
		final Scene root = new Scene()
			// the data definition has two elements, indicating two layers
			// will be constructed -- remember, Scene is a subclass of Layer.
			// That is, all child marks will be replicated twice.
			// The actual data values will be used to vertically offset nodes
			.data(Arrays.asList(0.0, 12.0))
			.left("{{300 * index}}") // place layers 300 pixels apart
			.scene();
		
		// add a first set of nodes
		Mark n1 = root.add(MarkType.Dot)
			.extend(n).top("{{50 - (Double)parent.data}}");
		
		// add blue edges to the nodes
		n1.add(MarkType.Link).extend(e)
			.stroke(Stroke.solid(3, 0xdedeff));
		
		// add a second set of nodes, aligned beneath the first set
		Mark n2 = root.add(MarkType.Dot)
			.extend(n).top("{{100 + (Double)parent.data}}");
		
		// add red edges to the node
		n2.add(MarkType.Link).extend(e)
			.stroke(Stroke.solid(3, 0xffdede));
		
		// Finally, add edge set 2 to connect the two node sets together
		// Ask yourself why this works. It is a bit subtle...
		// Recall that we are replicating the data across multiple layers.
		// As a result of this, each mark definition has multiple sets of
		// associated scene graph items (one for each layer instance).
		// Behind the scenes, protovis does the appropriate bookkeeping so
		// that the right set of nodes is used for the corresponding layer.
		root.add(MarkType.Link).extend(e)
			.data(edges2)
			.sourceNodes(n1) // uses nodes generated by mark n1
			.targetNodes(n2) // uses nodes generated by mark n2
			;
		
		// Update causes all the scene graph items to be generated
		root.update();
		
		// Create a new display using an OpenGL renderer
		GLDisplay display = new GLDisplay();
	    display.setSize(600, 150);
	    display.addScene(root);
	    // Add a pan/zoom/rotate control
	    new CameraControl().attach(display);
	    
	    // Create a window and show the visualization
	    JFrame frame = new JFrame("Multi-Graph Test");
		frame.getContentPane().add(display);
		frame.pack();
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setVisible(true);
	}

}
