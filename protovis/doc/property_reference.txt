PROTOVIS PROPERTY REFERENCE

This document provides a quick property reference for the Java
implementation of the Protovis language. For details on the high-level
design of Protovis, please see http://protovis.org or the following
research papers:

http://vis.stanford.edu/papers/protovis
http://vis.stanford.edu/papers/protovis-design

MARK TYPES

All Protovis visualizations are constructed using a small palette of basic mark
types. Each mark represents a specific type of graphical item, such as a
rectangle, line, image, or label.

* Area - a filled or stroked area, such as in stacked area graphs
* Bar - a rectangular area
* Dot - a point (as in a scatter plot) that can take on a number of shapes
* Image - a bitmap image
* Label - a textual label, with specified text, font, and alignment
* Panel - a replicable container for other graphical items
* Line - a stroked path (as in a line chart) or a closed polygon
* Link - a path connecting two other marks, as in a node-link diagram
* Rule - a straight line, convenient for chart gridlines
* Wedge - an angular wedge, as in pie and donut charts


TERMINOLOGY

By "mark" we mean a mark specification: a set of properties that compute
visual encodings for a particular type of graphical element. Property
definitions may be compiled instances of the pv.mark.property.Property
class, or may be specified as "anonymous functions" -- localized snippets
of code that are later dynamically compiled.

Chained mark definitions support "inheritance". That is, a mark added to
another using the "add" method will inherit its property definitions by
default. The one exception is for panels--inheritance does not pass through
panel marks.

By "item" we mean a visual item, generated by a mark specification. Items
are represented using the pv.scene.Item class and related sub-classes. Items
are organized into a tree structure to form a scenegraph. The Protovis
scenegraph groups all items from a mark into a shared GroupItem. Each
instantiation of a panel mark results in a PanelItem which in turn keeps a
list of the contained GroupItems.


PROTOVIS PIPELINE

Protovis visualizations are built in a multi-step pipeline:

1. Specification

The designer / developer writes the protovis specification using the mark
types and properties described below. Each visualization starts with a Scene
mark, which is the root mark of the specification. The visualization is then
constructed when the update() method is invoked on the scene.

2. Bind

When update is called, each mark specification is evaluated. The first step
in this process is the bind phase, in which the mark hierarchy is traversed to
resolve all property definitions. This is when inheritance relationships are
resolved. If necessary, Protovis then compiles all property definitions for a
given mark into a new pv.mark.eval.Evaluator instance.

3. Build

The build phase is when the scenegraph items are generated and all properties
are evaluated. Protovis traverses the mark hierarchy, generating the full
scenegraph for the visualization. At the end of this process a separate tree
of Item instances is constructed which represents the visualization. Note that
the scenegraph tree may be much more complex than the mark hierarchy -- this is
because multiple panels (e.g., as in small multiples) may be constructed to
create branches in the scenography.

4. Render

The render phase is when the scenegraph items are drawn, either to the screen
or other consumer. Rendering is managed by a Display instance, which uses an
internal Renderer to traverse the scenegraph and draw the visualization.
The current release provides two renderers: OpenGL (using the GLDisplay class)
and Java2D (using the Java2DDisplay class). The OpenGL renderer has much
better performance, but requires the presence of a supported graphics card
and installed JOGL (Java OpenGL bindings) libraries.


SHARED PROPERTIES

These are the properties shared by all mark types. However, note that select
mark types may ignore one or more of these properties completely.

* data

Specifies the data set to be visualized. This must be either a single object
(just one data element) or an Iterable collection (providing multiple data
elements). For example, the data is often an instance of java.util.List,
though singleton elements are also allowed. The mark will iterate over the
elements to generate corresponding visual items.

* datatype

The data type (a java.lang.Class instance) of elements provided by the data
property. This property provides a "hint" that allows one to avoid manual
type-casting in dynamically compiled property definitions, simulating
dynamically-typed programming languages. If the datatype does not match the
actual type of the data elements, a class cast exception will occur on
visualization updates.

* def

Defines a named variable, associating a name with either a constant value or
a Variable instance. The variable value will be available to items within
anonymous property definitions by the given name. Also accessible is a setter
method of the same name. For example, one might add a variable definition
such as:

mark.def("elm", -1);

This variable can be accessed in anonymous property functions, e.g.,:

mark.fill("{{Fill.solid(elm == index ? 0xff0000 : 0x0000ff)}}");

Or the value can be updates within an anonymous property function, e.g.,:

mark.mouseEnter("{{elm(index).update()}}")
    .mouseExit("{{elm(-1).update()}}");

A variable definition is shared across all instances of the particular
mark type. System behavior is undefined when using a variable name that
interferes with other property or variable definitions.

* visible

Determines the visibility of an individual item.

* alpha

The overall alpha, or transparency, of an item. 0 -> invisible, 1 -> opaque.

* left

The x-coordinate of the element, measured from the left edge of the parent
panel. For a panel, this specifies the left padding.

If left is specified, right should not be specified (except for panels).
Take care if you switch between left- and right-based marks in your prototype
chain, as child marks will inherit previous properties.

* right

The x-coordinate of the element, measured from the right edge of the parent
panel. For a panel, this specifies the right padding.

If right is specified, left should not be specified (except for panels).
Take care if you switch between left- and right-based marks in your prototype
chain, as child marks will inherit previous properties.

* top

The y-coordinate of the item, measured from the top edge of the parent
panel. For a panel, this specifies the top padding.

If top is specified, bottom should not be specified  (except for panels).
Take care if you switch between top- and bottom-based marks in your prototype
chain, as child marks will inherit previous properties.

* bottom

The y-coordinate of the item, measured from the bottom edge of the parent
panel. For a panel, this specifies the bottom padding.

If top is specified, bottom should not be specified  (except for panels).
Take care if you switch between top- and bottom-based marks in your prototype
chain, as child marks will inherit previous properties.

* width

The width of the item.
This is ignored by the Dot, Label, Line, Link, and Wedge mark types.

* height

The height of the item.
This is ignored by the Dot, Label, Line, Link, and Wedge mark types.

* fill

The fill color of the item, specified as a pv.style.Fill instance.
This is ignored by the Link mark type, and some shapes provided by
the Dot mark type. Labels use the fill as their text color.

* stroke

The stroke width and color for the item, as a pv.style.Stroke instance.
This is ignored by the Label mark type.


MARK-SPECIFIC PROPERTIES

AREA and LINE MARKS

* segmented

Determines if each area or line segment should be treated individually. If true,
each segment can define varying line widths and colors. If false, the styling
parameters of the first element will be used for the full area or line. This
property is evaluated only once for a set of items.

* interpolate

Determines the interpolation type for areas and lines. This can be used, to
switch between discrete (step function) and continuous (sloped line) forms.
Legal values are represented in the Interpolate interface, and include
"linear", "step-before", and "step-after". This property is evaluated only
once for a set of items.

DOT MARKS

* size

The size (area) of the dot. The square root of this value is used to determine
the radius of the dot shape.

* shape

A string constant indicating the shape of the dot item. See the Shape interface
for available options, including "circle", "square", "diamond", etc.

IMAGE MARKS

* url

A url from which to load the image data.

LABEL MARKS

* font

The font of the label, as a pv.style.Font instance.

* text

The text string to be shown in the label.

* textAlign

A String constant indicating the horizontal alignment of the text. See the
TextAlign interface for options, including "left", "right", and "center".

* textAngle

The orientation at which to draw the text string, in radians. The default value
is 0.

* textBaseline

A String constant indicating the vertical alignment of the text. See the
TextBaseline interface for options, including "top", "bottom", and "middle".

* textMargin

The margin (padding) by which to offset a text label.

PANEL MARKS

* cache

A flag indicating if panel contents should be rendered into a cached image or
video memory texture. This can greatly improve performance for large elements
that change very infrequently. Note however, it should not be used if contained
items update often. This property is evaluated only once for a set of items.

* depth

A value indicating the depth or rendering sort order of groups within the same
panel. By default, links have a value of 1 and all other marks a value of 0, so
links are drawn behind other marks. Use this property to change the rendering
order. However, note that the sort order only applies to items within the same
panel. This property is evaluated only once for a set of items.

LINK MARKS

* sourceNodes

A Mark or GroupItem instance indicating the set of items that constitute the
source nodes for the links. If a Mark instance is provided, Protovis will try
to find a corresponding GroupItem within the same panel. By default, links
use their prototype GroupItem, effectively "inheriting" nodes from their
parent in the mark hierarchy.

* targetNodes

A Mark or GroupItem instance indicating the set of items that constitute the
source nodes for the links. If a Mark instance is provided, Protovis will try
to find a corresponding GroupItem within the same panel. By default, links
use their prototype GroupItem, effectively "inheriting" nodes from their
parent in the mark hierarchy.

* nodes

A convenience property that sets both source and target nodes to the same
set of nodes.

* sourceNodeKey

A primary key function that uniquely identifies source nodes. This is used to
resolve keys within link data against node instances. The function is invoked
on items in the source nodes collection.

* targetNodeKey

A primary key function that uniquely identifies target nodes. This is used to
resolve keys within link data against node instances. The function is invoked
on items in the target nodes collection.

* nodeKey

A convenience property that sets both sourceNodeKey and targetNodeKey to the
same property value.

* sourceKey

A foreign key function that lookups the key value for the source node of a
link. The function is invoked on items in the links collection (the "data"
elements for this mark).

* targetKey

A foreign key function that lookups the key value for the target node of a
link. The function is invoked on items in the links collection (the "data"
elements for this mark).

WEDGE MARKS

* innerRadius

The inner radius of the wedge. This is 0 by default, resulting in circular
(pie) slices.

* outerRadius

The outer radius of the wedge.

* startAngle

The start angle (in radians) of the wedge. By default, this value is the end
angle of the previous sibling item, or 0 if there is no previous sibling.

* endAngle

The end angle (in radians) of the wedge.

* angle

The angular width of the wedge. This can be used instead of endAngle to define
wedges relative to one another in sequence.


ANIMATION PROPERTIES

These properties support keyframe animation of items in the scenegraph,
including control over how items enter and exit the scene. All mark types
support animation properties. To invoke an animation, the Scene.update()
method should be called with an animation duration parameter -- e.g.,
update(1) for a 1 second transition.

* key

A value determining the unique identity of an item within a mark set. This is
used to determine correspondences between items when animating between a start
state and an end state. By default, the data element itself is used as the key.
If the data elements does not hash to unique value within the mark set, an
explicit key definition is required for animation to work correctly.

* enter

A mark instance providing a bundle of properties defining the behavior and
appearance of an item when it is first added to the scene. By default, entering
items fade in from alpha=0. The enter property enables designers to specify
customized behavior, such as "sliding in" from the side.

* exit

A mark instance providing a bundle of properties defining the behavior and
appearance of an item when it is removed from the scene. By default, exiting
items fade out to alpha=0. The exit property enables designers to specify
customized behavior, such as "sliding out" to the side.

* delay

Determines a delay, in seconds, before animation for the item should begin.
By default the delay is 0. The delay property can be used to stagger the
animation of items in a set.

* ease

The easing function that should be used to pace an item's animation. Easing
functions can be used to create effects such as slow-in, slow-out animation
(the default), variable speeds, and even "bouncing" effects.


INTERACTION CALLBACKS

These properties specify interactive behaviors in response to mouse and key
events. The standard array of callbacks is provided, as listed below. Each
callback is an instance of the EventHandler class, which has a single method
named "handle" which takes a MarkEvent and an Item as arguments. For
anonymous callback definitions, these are automatically accessible as the
"event" and "item" variables, respectively. Key events are triggered when the
mouse is over an item and a key is pressed.

* mouseEnter
* mouseExit
* mousePress
* mouseRelease
* mouseClick
* mouseMove
* mouseDrag
* mouseWheel
* keyPress
* keyRelease
* keyType 


